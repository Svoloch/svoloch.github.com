// Generated by CoffeeScript 1.10.0
var $F, Error,
  slice = [].slice;

$F = function(fn) {
  return $F.prototype(function() {
    return fn.apply(this, arguments);
  });
};

$F.prototype = function(fn) {
  fn.constructor = $F;
  fn.__proto__ = $F.prototype;
  return fn;
};

$F.prototype.then = function() {
  var args, current, fn;
  fn = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  current = this;
  return this.constructor.prototype(function() {
    return fn.call.apply(fn, [this, current.apply(this, arguments)].concat(slice.call(args)));
  });
};

$F.prototype["catch"] = function() {
  var args, current, fn;
  fn = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  current = this;
  return this.constructor.prototype(function() {
    var e, error;
    try {
      return current.apply(this, arguments);
    } catch (error) {
      e = error;
      return fn.call.apply(fn, [this, e].concat(slice.call(args)));
    }
  });
};

$F.prototype.bind = Function.prototype.bind(typeof "function") ? function() {
  return this.constructor.prototype(Function.prototype.bind.apply(this, arguments));
} : function() {
  var current;
  current = this;
  return this.constructor.prototype(function(self) {
    return function() {
      return current.apply(self, arguments);
    };
  });
};

$F.prototype.bindArgsStrict = function() {
  var args, current;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  current = this;
  return this.constructor.prototype(function() {
    return current.apply(this, args);
  });
};

$F.prototype.bindArgs = function() {
  var current, startArgs;
  startArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  current = this;
  return this.constructor.prototype(function() {
    var args, restArgs;
    restArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    args = [];
    args.push.apply(args, startArgs);
    args.push.apply(args, restArgs);
    return current.apply(this, args);
  });
};

$F.prototype.argToThis = function(self) {
  var current;
  current = this.bind(self);
  return this.constructor.prototype(function() {
    return current.apply(null, [this].concat(slice.call(arguments)));
  });
};

$F.prototype.thisToArg = function() {
  return this.constructor.prototype(this.call).bind(this);
};

$F.prototype.catchCond = function(cond, fn) {
  return this["catch"](function(e) {
    if (!cond.call(this, e)) {
      throw e;
    }
    return fn.call(this, e);
  });
};

$F.prototype.catchVal = function(val, fn) {
  return this.catchCond((function(e) {
    return e === val;
  }), fn);
};

$F.prototype.catchType = function(type, fn) {
  return this.catchCond(((function(_this) {
    return function(e) {
      return _this.constructor.as(e, type);
    };
  })(this)), fn);
};

$F.prototype["default"] = function(value) {
  return this["catch"](function() {
    return value;
  });
};

$F.prototype.loop = function(fn) {
  var current;
  current = this;
  return this.constructor.prototype(function() {
    var e, error, val;
    val = current.apply(this, arguments);
    try {
      while (true) {
        val = fn.call(this, val);
      }
    } catch (error) {
      e = error;
      return e;
    }
  });
};

$F.prototype.times = function(times, self) {
  var index, results;
  index = 0;
  results = [];
  while (index++ < times) {
    results.push(this.call(self, index));
  }
  return results;
};

$F.prototype.repeat = function(times, self) {
  var index;
  index = 0;
  while (index++ < times) {
    this.call(self, index);
  }
  return this;
};

$F.prototype.curry = function(times) {
  var current;
  if (times == null) {
    times = 1;
  }
  if (--times <= 0) {
    return this;
  }
  current = this;
  return this.constructor.prototype(function(first) {
    return current.constructor(function() {
      return current.call.apply(current, [this, first].concat(slice.call(arguments)));
    }).curry(times);
  });
};

$F.prototype.bindedCurry = function(times) {
  var current;
  if (times == null) {
    times = 1;
  }
  if (--times <= 0) {
    return this;
  }
  current = this;
  return this.constructor.prototype(function(first) {
    return current.constructor((function(_this) {
      return function() {
        return current.call.apply(current, [_this, first].concat(slice.call(arguments)));
      };
    })(this)).curry(times);
  });
};

$F.prototype.curryBreak = function() {
  var current, step, steps;
  steps = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  if (!steps.length) {
    return this;
  }
  current = this;
  step = steps[0];
  return function() {
    var ref, startArgs;
    startArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    startArgs = startArgs.slice(0, Math.max(0, step));
    return (ref = current.constructor.prototype(function() {
      var args, restArgs;
      restArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      args = [];
      args.push.apply(args, startArgs);
      args.push.apply(args, restArgs);
      return current.apply(this, args);
    })).curryBreak.apply(ref, steps.slice(1));
  };
};

$F.prototype.preprocessAll = function(fn) {
  var current;
  current = this;
  return this.constructor.prototype(function() {
    var arr;
    arr = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return current.apply(this, fn.call(this, arr));
  });
};

$F.prototype.flip = function(from, to) {
  var ref;
  if (from == null) {
    from = 0;
  }
  if (to == null) {
    to = 1;
  }
  if (from === to) {
    return this;
  }
  ref = [Math.min(from, to), Math.max(from, to)], from = ref[0], to = ref[1];
  return this.preprocessAll(function(arr) {
    var res;
    res = [];
    res.push.apply(res, arr.slice(0, from));
    res.push(arr[to]);
    res.push.apply(res, arr.slice(from + 1, to));
    res.push(arr[from]);
    res.push.apply(res, arr.slice(to + 1));
    return res;
  });
};

$F.prototype.preprocess = function() {
  var current, fns;
  fns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  current = this;
  return this.constructor.prototype(function() {
    var args, fn, j, len, pos;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (pos = j = 0, len = fns.length; j < len; pos = ++j) {
      fn = fns[pos];
      args[pos] = fn.call(this, args[pos]);
    }
    return current.apply(this, args);
  });
};

$F.prototype.preprocessStrict = function() {
  var current, fns;
  fns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  current = this;
  return this.constructor.prototype(function() {
    var args, fn, pos;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return current.apply(this, (function() {
      var j, len, results;
      results = [];
      for (pos = j = 0, len = fns.length; j < len; pos = ++j) {
        fn = fns[pos];
        results.push(fn.call(this, args[pos]));
      }
      return results;
    }).call(this));
  });
};

$F.prototype.guard = function(cond) {
  return this.then(function(value) {
    if (!cond.call(this, value)) {
      throw new this.Error;
    }
    return value;
  });
};

$F.prototype.guardType = function(type) {
  return this.guard((function(_this) {
    return function(value) {
      return _this.constructor.as(value, type);
    };
  })(this));
};

$F.prototype.guardArgs = function() {
  var conds, current;
  conds = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  current = this;
  return this.constructor.prototype(function() {
    var cond, j, len, pos;
    for (pos = j = 0, len = conds.length; j < len; pos = ++j) {
      cond = conds[pos];
      if (!cond.call(this, arguments[pos])) {
        throw new Error;
      }
    }
    return current.call(this, arguments);
  });
};

$F.prototype.guardArgsTypes = function() {
  var type, types;
  types = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return this.guardArguments.apply(this, (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = types.length; j < len; j++) {
      type = types[j];
      results.push((function(_this) {
        return function(value) {
          return _this.constructor.as(value, type);
        };
      })(this));
    }
    return results;
  }).call(this));
};

$F.prototype.zipper = function() {
  var current;
  current = this;
  return this.constructor.prototype(function() {
    var arr, arrs, i, j, ref, results;
    arrs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    results = [];
    for (i = j = 0, ref = Math.min.apply(Math, (function() {
      var k, len, results1;
      results1 = [];
      for (k = 0, len = arrs.length; k < len; k++) {
        arr = arrs[k];
        results1.push(arr.length);
      }
      return results1;
    })()); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push(current.apply(this, (function() {
        var k, len, results1;
        results1 = [];
        for (k = 0, len = arrs.length; k < len; k++) {
          arr = arrs[k];
          results1.push(arr[i]);
        }
        return results1;
      })()));
    }
    return results;
  });
};

$F.prototype.zipWith = function() {
  var arrs, self;
  self = arguments[0], arrs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  return this.zipper().apply(self, arrs);
};

$F.prototype.zip = function() {
  var arrs;
  arrs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return this.zipper().apply(null, arrs);
};

$F.prototype.objectZipper = function(defDest) {
  var current;
  current = this;
  return this.constructor.prototype(function() {
    var dest, j, key, keys, len, obj, objs, ref;
    objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    keys = (ref = current.constructor).commonKeys.apply(ref, objs);
    dest = defDest != null ? defDest : {};
    for (j = 0, len = keys.length; j < len; j++) {
      key = keys[j];
      dest[key] = current.apply(this, (function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = objs.length; k < len1; k++) {
          obj = objs[k];
          results.push(obj[key]);
        }
        return results;
      })());
    }
    return dest;
  });
};

$F.commonKeys = function() {
  var j, key, keys, len, less, obj, objs, pos, res;
  objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  keys = (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = objs.length; j < len; j++) {
      obj = objs[j];
      results.push(((function() {
        var results1;
        results1 = [];
        for (key in obj) {
          results1.push(key);
        }
        return results1;
      })()).sort());
    }
    return results;
  })();
  res = [];
  try {
    while (true) {
      if (!keys[0].length) {
        break;
      }
      less = keys[0][0];
      pos = 0;
      while (pos < keys.length) {
        while (keys[pos].length && keys[pos][0] < less) {
          keys[pos].shift();
        }
        if (!keys[pos].length) {
          throw null;
        }
        if (keys[pos][0] > less) {
          less = keys[pos][0];
          pos = 0;
          continue;
        }
        pos++;
      }
      res.push(less);
      for (j = 0, len = keys.length; j < len; j++) {
        key = keys[j];
        key.shift();
      }
    }
  } catch (undefined) {}
  return res;
};

$F.prototype.zipObjects = function() {
  var objs;
  objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return this.objectZipper().apply(null, objs);
};

$F.prototype.zipObjectsWith = function() {
  var objs, self;
  self = arguments[0], objs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  return this.objectZipper().apply(self, objs);
};

$F.prototype.zipObjectsTo = function() {
  var dest, objs;
  dest = arguments[0], objs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  return this.objectZipper(dest).apply(null, objs);
};

$F.prototype.cell = function() {
  var changed, current, destroyed, j, len, param, params, recalc, res, value;
  params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  current = this;
  value = null;
  changed = false;
  destroyed = false;
  (recalc = function() {
    var param;
    if (destroyed) {
      throw new current.Error();
    }
    changed = false;
    return value = current.apply(null, (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = params.length; j < len; j++) {
        param = params[j];
        results.push(param());
      }
      return results;
    })());
  })();
  res = this.constructor.prototype(function() {
    if (!changed) {
      return value;
    } else {
      return recalc();
    }
  })["catch"](function(e) {
    changed = true;
    throw e;
  });
  for (j = 0, len = params.length; j < len; j++) {
    param = params[j];
    param.relateds.push(res);
  }
  res.relateds = [];
  res.recalc = recalc;
  res.markChange = function() {
    var k, len1, ref, related;
    if (changed) {
      return res;
    }
    changed = true;
    ref = res.relateds;
    for (k = 0, len1 = ref.length; k < len1; k++) {
      related = ref[k];
      related.markChange();
    }
    return res;
  };
  res.destroy = function() {
    var item, k, len1, results;
    results = [];
    for (k = 0, len1 = params.length; k < len1; k++) {
      param = params[k];
      results.push(param.relateds = (function() {
        var l, len2, ref, results1;
        ref = param.relateds;
        results1 = [];
        for (l = 0, len2 = ref.length; l < len2; l++) {
          item = ref[l];
          if (item !== res) {
            results1.push(item);
          }
        }
        return results1;
      })());
    }
    return results;
  };
  return res;
};

$F.cell = function(value) {
  var res;
  res = this.prototype(function(newValue) {
    var j, len, ref, related;
    if (arguments.length) {
      if (value !== newValue) {
        value = newValue;
        ref = res.relateds;
        for (j = 0, len = ref.length; j < len; j++) {
          related = ref[j];
          related.markChange();
        }
      }
    }
    return value;
  });
  res.relateds = [];
  res.recalc = function() {
    return value;
  };
  return res;
};

$F.as = $F.prototype(function(value, type) {
  return (typeof value === type) || (value instanceof type) || (value.constructor === type);
})["default"](false);

$F.Error = Error = (function() {
  function Error() {}

  Error.prototype.toString = function() {
    return "not implemented!";
  };

  return Error;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = $F;
}

$F.prototype.fnFlip = function() {
  var current;
  current = this;
  return function() {
    var fstArgs, fstThis;
    fstArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    fstThis = this;
    return function() {
      var sndArgs;
      sndArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (current.apply(this, sndArgs)).apply(fstThis, fstArgs);
    };
  };
};

$F.inherit = function() {
  var Type;
  Type = function(fn) {
    return Type.prototype(function() {
      return fn.apply(this, arguments);
    });
  };
  Type.prototype = this.prototype(function(fn) {
    fn.constructor = Type;
    fn.__proto__ = Type.prototype;
    return fn;
  });
  Type.constructor = Type;
  Type.__proto__ = this;
  return Type;
};
